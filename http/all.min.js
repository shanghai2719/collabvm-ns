(function (window, $) {
    'use strict';

    /******************************************************************
     * CONFIG
     ******************************************************************/
    const AppConfig = {
        rootDir: '/collab-vm',         // trùng với index.html
        serverAddress: window.location.host,
        chatSoundBase: 'notify',       // notify.mp3 / .ogg / .m4a
        maxChatMsgLen: 100,
        maxChatHistory: 100,
        uploadMaxSize: 4096 * 1024,    // 4 MB (tuỳ chỉnh)
        uploadMaxFilename: 100
    };

    /******************************************************************
     * GLOBAL STATE (UI)
     ******************************************************************/
    const State = {
        DISCONNECTED: 'disconnected',
        CONNECTING: 'connecting',
        CONNECTED: 'connected'
    };

    const AppState = {
        tunnelState: State.DISCONNECTED,
        vmName: null,
        username: null,
        users: {},           // { name: [roleId, hasTurn, isSelf, waiting] }
        userOrder: [],       // danh sách tên để hiển thị
        votes: {
            yes: 0,
            no: 0,
            expiresAt: null,
            timerId: null
        },
        chatSoundEnabled: true,
        chatAudio: null,
        nsfwMasked: true,
        uploadToken: null,   // chừa sẵn nếu backend cần
        hasKeyboardFocus: false,
        hasTurn: false,
        chatHistoryCount: 0
    };

    /******************************************************************
     * COOKIE UTIL
     ******************************************************************/
    function getCookie(name) {
        const key = name + '=';
        const parts = document.cookie.split(';');
        for (let i = 0; i < parts.length; i++) {
            let c = parts[i];
            while (c.charAt(0) === ' ') c = c.substring(1);
            if (c.indexOf(key) === 0) {
                return c.substring(key.length, c.length);
            }
        }
        return '';
    }

    function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = 'expires=' + d.toUTCString();
        document.cookie = name + '=' + value + '; ' + expires + '; path=/';
    }

    /******************************************************************
     * CHAT SOUND
     ******************************************************************/
    function initChatSound() {
        if (!document.createElement('audio').canPlayType) return;

        const audioTest = document.createElement('audio');
        const base = AppConfig.chatSoundBase;

        if (audioTest.canPlayType('audio/mpeg;').replace(/no/, '')) {
            AppState.chatAudio = new Audio(base + '.mp3');
        } else if (audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/no/, '')) {
            AppState.chatAudio = new Audio(base + '.ogg');
        } else if (audioTest.canPlayType('audio/mp4; codecs="mp4a.40.2"').replace(/no/, '')) {
            AppState.chatAudio = new Audio(base + '.m4a');
        }
    }

    function setChatSoundEnabled(enabled) {
        AppState.chatSoundEnabled = !!enabled;
        const icon = $('#chat-sound-btn').children().first();
        if (AppState.chatSoundEnabled) {
            icon.removeClass('glyphicon-volume-off').addClass('glyphicon-volume-up');
        } else {
            icon.removeClass('glyphicon-volume-up').addClass('glyphicon-volume-off');
        }
    }

    function playChatSound() {
        if (!AppState.chatSoundEnabled) return;

        if (AppState.chatAudio) {
            AppState.chatAudio.play().catch(() => { /* ignore */ });
        } else {
            // fallback <bgsound> (cũ)
            $('#chat-sound bgsound').remove();
            $('<bgsound/>')
                .attr({
                    src: 'notify.mp3',
                    loop: 1,
                    autostart: 1
                })
                .appendTo('#chat-sound');
        }
    }

    /******************************************************************
     * NSFW MASK
     ******************************************************************/
    function setNsfwMasked(masked) {
        AppState.nsfwMasked = !!masked;

        if (!AppState.nsfwMasked) {
            $('#display').removeClass('censor censor-fallback');
            $('#vm-list img').removeClass('censor censor-fallback');
            $('#warning').hide();
        } else {
            const $display = $('#display');
            $display.addClass('censor');
            // check CSS filter support
            let supportsFilter = $display.css('filter') || $display.css('-webkit-filter');
            if (supportsFilter) {
                // IE9 fallback detection (the bản gốc làm kiểu này) :contentReference[oaicite:1]{index=1}
                supportsFilter = (typeof document.documentMode === 'undefined' || document.documentMode > 9);
            }
            if (!supportsFilter) {
                $display.addClass('censor-fallback');
            }

            $('#warning').show();
        }
    }

    /******************************************************************
     * VIEW SWITCHING
     ******************************************************************/
    function setLoading(loading) {
        if (!loading) {
            $('#loading').hide();
            $('#status').html('');
        } else {
            $('#loading').show();
            $('#status').html('Loading.');
        }
    }

    function showVmListView(show) {
        if (!show) {
            $('#vm-list').empty().hide();
        } else {
            $('#vm-view').hide();
            $('#vm-list').empty().show();
        }
    }

    function showVmView(show) {
        if (!show) {
            $('#vm-view').hide();
        } else {
            $('#vm-list').hide();
            $('#vm-view').show();
            // nếu dùng OnScreenKeyboard thì resize ở đây
            const $kbdContainer = $('#kbd-container');
            if ($kbdContainer.length) {
                // Keyboard lib tuỳ em gắn
            }
        }
    }

    /******************************************************************
     * VM LIST RENDER
     * server nên trả về 1 mảng: [id, name, base64Thumb, id, name, base64Thumb, ...]
     ******************************************************************/
    function renderVmList(flatList) {
        const $list = $('#vm-list');
        $list.empty();

        if (!flatList || !flatList.length) {
            $list.html('No VMs online');
            return;
        }

        for (let i = 0; i < flatList.length; i += 3) {
            const slug = flatList[i];
            const name = flatList[i + 1];
            const image = flatList[i + 2];

            const $card = $(`
                <div class="col-sm-6 col-md-4">
                    <a class="thumbnail" href="#${AppConfig.rootDir}/${slug}">
                        ${image ? `<img src="data:image/png;base64,${image}"/>` : ''}
                        <div class="caption"><h4>${name}</h4></div>
                    </a>
                </div>
            `);

            $card.children().first().on('click', function (ev) {
                if (ev.which === 1) {
                    ev.preventDefault();
                    const href = this.getAttribute('href');
                    const vmSlug = href.substr(href.lastIndexOf('/') + 1);
                    // chọn VM
                    AppState.vmName = vmSlug;
                    Backend.connectToVm(vmSlug);
                }
            });

            // nếu đang NSFW mask thì mask cả thumbnail
            if (AppState.nsfwMasked && image) {
                const imgEl = $card.children().first().children().first();
                imgEl.addClass('censor'); // hoặc censor-fallback nếu muốn
            }

            $list.append($card);
        }
    }

    /******************************************************************
     * VOTE UI
     ******************************************************************/
    function setVoteStats(info) {
        // info: [opcode, remainingMs, yesCount, noCount]
        clearVoteTimer();

        if (!info) {
            $('#vote-stats').hide();
            $('#vote-alert').hide();
            $('#vote-pass, #vote-cancel').hide();
            $('#vote-time').text('');
            return;
        }

        const remainingMs = parseInt(info[1], 10) || 0;
        const yes = info[2] ?? 0;
        const no = info[3] ?? 0;

        $('#vote-label-yes').text(yes);
        $('#vote-label-no').text(no);

        AppState.votes.yes = yes;
        AppState.votes.no = no;
        AppState.votes.expiresAt = Date.now() + remainingMs;

        if (remainingMs > 0) {
            $('#vote-stats').show();
            AppState.votes.timerId = startCountdown(remainingMs, function update(t, dots) {
                if (t === null) {
                    $('#vote-time').text('0s');
                } else {
                    const sec = Math.floor(t / 1000);
                    $('#vote-time').text(sec + 's' + dots);
                }
            });
        } else {
            $('#vote-stats').show();
            $('#vote-time').text('0s');
        }
    }

    function clearVoteTimer() {
        if (AppState.votes.timerId) {
            clearInterval(AppState.votes.timerId);
            AppState.votes.timerId = null;
        }
    }

    function startCountdown(durationMs, cb) {
        let remaining = durationMs;
        let dots = '';

        function tick() {
            const n = Math.floor(remaining / 1000);
            if (n <= 0) {
                clearInterval(id);
                cb(null, '');
                return;
            }
            dots = dots.length < 3 ? dots + '.' : '';
            cb(remaining, dots);
        }

        tick();
        const id = setInterval(function () {
            remaining -= 1000;
            tick();
        }, 1000);

        return id;
    }

    /******************************************************************
     * USER LIST
     ******************************************************************/
    function roleIdToClass(roleId) {
        switch (roleId) {
            case 1: return 'user';
            case 2: return 'admin';
            case 3: return 'moderator';
            case 4: return 'dev';
            default: return '';
        }
    }

    function renderUserList() {
        const $container = $('#online-users');
        $container.empty();

        const order = AppState.userOrder;
        $('#users-online').text(order.length);

        order.forEach(function (name) {
            const info = AppState.users[name];
            if (!info) return;

            const roleId = info[0];
            const hasTurn = info[1] === 1;
            const isSelf = info[2] === 1;
            const isWaiting = info[3] === 1;

            const li = $('<li class="list-group-item user"></li>');
            li.text(name);

            const roleClass = roleIdToClass(roleId);
            if (roleClass) {
                li.addClass(roleClass);
            }

            if (isSelf) {
                li.addClass('current-user');
            }
            if (hasTurn) {
                li.addClass('has-turn');
            } else if (isWaiting) {
                li.addClass('waiting-turn');
            }

            li.on('click', function () {
                // hook admin menu tại đây nếu muốn
                // H.renameUser(name) kiểu cũ, giờ tuỳ em
            });

            $container.append(li);
        });
    }

    /******************************************************************
     * CHAT UI
     ******************************************************************/
    function appendChatMessage(opts) {
        // opts: { username, text, roleClass, isServer, time }
        const $wrapper = $('.message-pane');
        if (!$wrapper.length) return;

        const li = $('<li/>');
        const inner = $('<div/>');
        const timeLabel = $('<small/>');
        const spacer = $('<span class="spacer">»</span>');
        const nameSpan = $('<span class="username"></span>');
        const msgSpan = $('<span></span>');

        const t = opts.time || new Date();
        const hh = ('' + t.getHours()).padStart(2, '0');
        const mm = ('' + t.getMinutes()).padStart(2, '0');
        timeLabel.text(`${hh}:${mm}`);

        if (opts.isServer) {
            inner.addClass('server-message');
        }

        if (opts.roleClass) {
            nameSpan.addClass(opts.roleClass);
        }

        nameSpan.text(opts.username || 'Server');
        msgSpan.text(' ' + (opts.text || ''));

        inner.append(timeLabel);
        inner.append(nameSpan);
        inner.append(spacer);
        inner.append(msgSpan);

        li.append(inner);
        $wrapper.append(li);

        // giữ history
        AppState.chatHistoryCount++;
        while (AppState.chatHistoryCount > AppConfig.maxChatHistory) {
            const first = $wrapper.children().first();
            if (!first.length) break;
            first.remove();
            AppState.chatHistoryCount--;
        }

        const wrapperParent = $('.message-pane-wrapper');
        if (wrapperParent.length) {
            wrapperParent.scrollTop(wrapperParent[0].scrollHeight);
        }
    }

    /******************************************************************
     * BACKEND ADAPTER (STUB)
     *
     * Ở đây anh tạo lớp Backend để em gắn WebSocket + Guacamole/engine cũ.
     * - connectToVm(vmName): mở kết nối tới VM
     * - disconnect(): ngắt
     * - send(opcode, ...args): gửi message tới server (turn, vote, chat, admin, file, v.v…)
     * - on* handler: được gọi khi server gửi các event tương ứng
     ******************************************************************/
    const Backend = {
        ws: null,
        state: State.DISCONNECTED,
        vmName: null,

        connectToVm(vmName) {
            this.vmName = vmName;
            setLoading(true);
            showVmView(true);
            this.changeState(State.CONNECTING);

            // TODO: GẮN KẾT NỐI THẬT Ở ĐÂY
            // Ví dụ (tuỳ protocol của em):
            //
            // this.ws = new WebSocket('ws://' + AppConfig.serverAddress + '/', 'guacamole');
            // this.ws.onopen = () => {
            //     this.changeState(State.CONNECTED);
            //     this.send('connect', vmName);
            //     this.send('list'); // nếu cần
            // };
            // this.ws.onmessage = (ev) => {
            //     // decode message & gọi các handler this.handleInstruction(...)
            // };
            //
            // Tạm thời anh giả lập connect thành công sau 300ms:
            const self = this;
            setTimeout(function () {
                self.changeState(State.CONNECTED);
                setLoading(false);
                $('#status').text('Connected to ' + vmName);
            }, 300);
        },

        disconnect() {
            if (this.ws) {
                try { this.ws.close(); } catch (e) { /* ignore */ }
                this.ws = null;
            }
            this.changeState(State.DISCONNECTED);
            setLoading(false);
        },

        changeState(newState) {
            this.state = newState;
            AppState.tunnelState = newState;
            // update UI theo state nếu cần
        },

        send(opcode, ...args) {
            // TODO: encode message theo protocol thật
            //
            // Với Guacamole text protocol, có dạng:
            //   "<len>.<opcode>,<len>.<arg1>,...,;"
            //
            // Ở đây anh chỉ log ra console để tránh lỗi runtime:
            if (!this.ws || this.state !== State.CONNECTED) {
                console.warn('Backend.send() while not connected', opcode, args);
                return;
            }
            console.log('SEND', opcode, args);
        },

        // ==== CÁC HANDLER EM SẼ GỌI KHI GIẢI MÃ GÓI TIN ====

        handleList(flatList) {
            // server gửi danh sách VM
            showVmListView(true);
            showVmView(false);
            setLoading(false);
            renderVmList(flatList);
        },

        handleChatMessage(username, roleId, text, isServer) {
            const roleClass = roleIdToClass(roleId);
            appendChatMessage({
                username,
                text,
                roleClass: roleClass,
                isServer: !!isServer
            });
            if (!isServer) {
                playChatSound();
            }
        },

        handleUserJoin(name, roleId) {
            if (!AppState.users[name]) {
                AppState.userOrder.push(name);
            }
            AppState.users[name] = [roleId, 0, 0, 0];
            renderUserList();
        },

        handleUserLeave(name) {
            delete AppState.users[name];
            AppState.userOrder = AppState.userOrder.filter(n => n !== name);
            renderUserList();
        },

        handleTurnInfo(turnList, currentUser, remainingMs) {
            // turnList: [user, roleId, hasTurn, isSelf, waiting, user2, ...] – tuỳ em định nghĩa
            // currentUser: name đang có turn
            // remainingMs: thời gian còn lại
            // Ở đây anh chỉ cập nhật user flags, khá đơn giản
            for (let i = 0; i < turnList.length; i += 5) {
                const name = turnList[i];
                const roleId = turnList[i + 1] | 0;
                const hasTurn = turnList[i + 2] | 0;
                const isSelf = turnList[i + 3] | 0;
                const waiting = turnList[i + 4] | 0;

                AppState.users[name] = [roleId, hasTurn, isSelf, waiting];
                if (!AppState.userOrder.includes(name)) {
                    AppState.userOrder.push(name);
                }
                if (isSelf) AppState.username = name;
            }
            AppState.hasTurn = !!currentUser && currentUser === AppState.username;
            updateTurnButtons();
            renderUserList();
        },

        handleVoteInfo(info) {
            setVoteStats(info);
        }
    };

    /******************************************************************
     * TURN / BUTTON STATE
     ******************************************************************/
    function updateTurnButtons() {
        if (AppState.hasTurn) {
            $('#turn-btn').hide();
            $('#end-turn-btn').show();
        } else {
            $('#turn-btn').show();
            $('#end-turn-btn').hide();
        }
    }

    /******************************************************************
     * UPLOAD UI (CHỈ LÀM PHẦN FRONT, GÓI TIN EM GỬI BẰNG Backend.send)
     ******************************************************************/
    function validateUploadFile(file) {
        if (!file) return 'No file selected.';
        if (file.size > AppConfig.uploadMaxSize) {
            return 'File is too big. Max file size is ' + AppConfig.uploadMaxSize + ' bytes.';
        }
        if (file.name.length > AppConfig.uploadMaxFilename) {
            return 'Filename is too long. Max filename is ' + AppConfig.uploadMaxFilename + '.';
        }
        const invalid = /[^\x20-\x7E]|[<>:"/\\|?*]/;
        if (invalid.test(file.name)) {
            return 'Filename contains characters that are not allowed.';
        }
        return null;
    }

    /******************************************************************
     * INIT UI EVENTS
     ******************************************************************/
    function initUiEvents() {
        // NSFW continue
        $('#nsfw-cont-btn').on('click', function () {
            setNsfwMasked(false);
            if ($('#no-warn-chkbox').prop('checked')) {
                setCookie('no-nsfw-warn-v2', '1', 365);
            }
        });

        // Turn buttons
        $('#turn-btn').on('click', function () {
            if (Backend.state === State.CONNECTED) {
                Backend.send('turn');
            }
        });
        $('#end-turn-btn').on('click', function () {
            if (Backend.state === State.CONNECTED) {
                Backend.send('turn', '0');
            }
        });

        // Vote buttons
        $('#vote-btn').on('click', function () {
            Backend.send('vote', '1');
        });
        $('#vote-yes').on('click', function () {
            Backend.send('vote', '1');
            $('#vote-alert').hide();
        });
        $('#vote-no').on('click', function () {
            Backend.send('vote', '0');
            $('#vote-alert').hide();
        });
        $('#vote-cancel').on('click', function () {
            Backend.send('admin', '13', 0);
        });
        $('#vote-pass').on('click', function () {
            Backend.send('admin', '13', 1);
        });
        $('#vote-dismiss').on('click', function () {
            $('#vote-alert').hide();
        });

        // Username modal
        $('#username-modal').on('show.bs.modal', function () {
            $('#username-box').val(AppState.username || '');
        });

        $('#username-ok-btn').on('click', function () {
            const name = $('#username-box').val().trim();
            if (!name) return;
            $('#username-modal').modal('hide');
            AppState.username = name;
            // gửi rename
            if (Backend.state === State.CONNECTED) {
                Backend.send('rename', name);
            }
        });

        $('#username-box').on('keydown', function (ev) {
            if (ev.which === 13) {
                ev.preventDefault();
                $('#username-ok-btn').trigger('click');
            }
        });

        // Autotype modal
        $('#autotype-ok-btn').on('click', function () {
            const text = $('#autotype-box').val();
            if (!text) return;
            $('#autotype-modal').modal('hide');
            if (Backend.state === State.CONNECTED) {
                Backend.send('autotype', text);
            }
        });

        $('#autotype-box').on('keydown', function (ev) {
            if (ev.which === 13) {
                ev.preventDefault();
                $('#autotype-ok-btn').trigger('click');
            }
        });

        // Upload block
        const uploadsSupported = !!(
            window.File && window.FileReader &&
            window.FileList && window.Blob &&
            window.ArrayBuffer && window.Uint8Array
        );

        $('#upload-options-btn').on('click', uploadsSupported ? function () {
            const $panel = $('#file-upload');
            $panel.is(':visible') ? $panel.hide('fast') : $panel.show('fast');
        } : function () {
            alert('File uploads are not fully supported by your browser.');
        });

        if (uploadsSupported) {
            $('#upload-input').on('change', function (ev) {
                const files = ev.target.files;
                if (files.length === 1) {
                    const file = files[0];
                    const err = validateUploadFile(file);
                    if (err) {
                        alert(err);
                        this.value = null;
                        $('#upload-btn').prop('disabled', true);
                        return;
                    }
                    $('#upload-btn').prop('disabled', false);
                } else {
                    $('#upload-btn').prop('disabled', true);
                }
            });

            $('#upload-btn').on('click', function () {
                const files = $('#upload-input')[0].files;
                if (files.length !== 1) return;
                const file = files[0];

                const err = validateUploadFile(file);
                if (err) {
                    alert(err);
                    return;
                }

                const run = $('#upload-run-chkbox').prop('checked') ? 1 : 0;

                // Thông báo cho backend bắt đầu upload (opcode & kiểu tuỳ em)
                Backend.send('file', 'BEGIN', file.name, file.size, run);

                $(this).prop('disabled', true);
                $('#upload-input').prop('disabled', true);
                $('#upload-wait-time').text('Uploading.');

                // Phần truyền blob qua WebSocket / HTTP em tự gắn vào.
            });
        }

        // Admin buttons (chỉ gửi opcode – backend tự check quyền)
        $('#restore-btn').on('click', function () {
            if (AppState.vmName) Backend.send('admin', '8', AppState.vmName);
        });
        $('#reboot-btn').on('click', function () {
            if (AppState.vmName) Backend.send('admin', '10', AppState.vmName);
        });
        $('#clear-turn-queue-btn').on('click', function () {
            if (AppState.vmName) Backend.send('admin', '17', AppState.vmName);
        });
        $('#end-current-turn-btn').on('click', function () {
            // ví dụ: gửi admin end-turn cho user hiện tại
            if (!AppState.username) return;
            Backend.send('admin', '16', AppState.username);
        });
        $('#bypass-turn-btn').on('click', function () {
            Backend.send('admin', '20');
        });

        // Home button
        $('#home-btn').attr('href', AppConfig.rootDir).on('click', function (ev) {
            if (ev.which === 1) {
                ev.preventDefault();
                if ($('#vm-list').is(':visible')) {
                    // reload list
                    refreshVmList();
                } else {
                    window.history.pushState(null, null, this.getAttribute('href'));
                }
            }
        });

        // Chat input
        $('#chat-input')
            .on('keypress', function (ev) {
                if (ev.which === 13) {
                    ev.preventDefault();
                    $('#chat-send-btn').trigger('click');
                } else if (this.value.length >= AppConfig.maxChatMsgLen) {
                    ev.preventDefault();
                }
            })
            .on('input', function () {
                if (this.value.length > AppConfig.maxChatMsgLen) {
                    this.value = this.value.substr(0, AppConfig.maxChatMsgLen);
                }
            });

        $('#chat-send-btn').on('click', function () {
            const $input = $('#chat-input');
            const text = $input.val().trim();
            if (!text) return;
            if (Backend.state !== State.CONNECTED) return;

            Backend.send('chat', text);
            $input.val('');
        });

        $('#chat-sound-btn').on('click', function () {
            const newVal = !AppState.chatSoundEnabled;
            setChatSoundEnabled(newVal);
            setCookie('chat-sound', newVal ? '1' : '0', 365);
        });

        // Chat sound init
        initChatSound();
        setChatSoundEnabled(getCookie('chat-sound') !== '0');

        // NSFW warn init
        setNsfwMasked(getCookie('no-nsfw-warn-v2') !== '1');

        // một số hook khác (pip-btn, osk-btn...) tuỳ em triển khai tiếp
    }

    /******************************************************************
     * REFRESH VM LIST (gửi yêu cầu list tới backend)
     ******************************************************************/
    function refreshVmList() {
        setLoading(true);
        showVmView(false);
        showVmListView(true);

        // nếu backend đã open, yêu cầu list VM
        if (Backend.state === State.CONNECTED) {
            Backend.send('list');
        } else {
            // tuỳ em: có thể connect tới "hub" server rồi gửi 'list'
            setLoading(false);
        }
    }

    /******************************************************************
     * ENTRYPOINT
     ******************************************************************/
    function initApp() {
        initUiEvents();

        // Lúc load trang:
        // - nếu URL có hash /collab-vm/<vm>, em có thể tự parse và connect luôn.
        // - tạm thời anh chỉ load list.
        refreshVmList();
    }

    $(initApp);

    /******************************************************************
     * EXPOSE BACKEND (để em dùng ngoài nếu cần)
     ******************************************************************/
    window.CollabVM = {
        Backend: Backend,
        AppState: AppState,
        refreshVmList: refreshVmList
    };

})(window, jQuery);
